---
#- name: Remove Snap Neovim if present
#  become: true
#  ansible.builtin.shell: |
#    set -euo pipefail
#    if command -v snap >/dev/null 2>&1 && snap list nvim >/dev/null 2>&1; then
#      snap remove --purge nvim
#    fi
#  args:
#    executable: /bin/bash
#  register: snap_remove_nvim
#  changed_when: snap_remove_nvim.stdout != ""
#  failed_when: false
#  when: ansible_system == 'Linux'

- name: Add Neovim PPA on Ubuntu/Pop!_OS
  become: true
  ansible.builtin.apt_repository:
    repo: ppa:neovim-ppa/unstable
    state: present
  register: neovim_ppa_repo
  when:
    - ansible_facts['system'] == 'Linux'
    - (detected_distribution | default(ansible_facts['distribution'] | lower | regex_replace('[^a-z0-9_]+', '_'))) in ['ubuntu', 'pop_os']

- name: Configure NodeSource Node.js 20.x repository
  when:
    - ansible_facts['system'] == 'Linux'
  block:
    - name: Check if NodeSource keyring exists
      stat:
        path: /usr/share/keyrings/nodesource.gpg
      register: nodesource_keyring

    - name: Download NodeSource signing key
      ansible.builtin.get_url:
        url: https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key
        dest: /tmp/nodesource.gpg.key
        mode: "0644"
      when: not nodesource_keyring.stat.exists

    - name: Install NodeSource signing key
      become: true
      ansible.builtin.command: gpg --dearmor --yes --output /usr/share/keyrings/nodesource.gpg /tmp/nodesource.gpg.key
      when: not nodesource_keyring.stat.exists

    - name: Remove temporary NodeSource key
      ansible.builtin.file:
        path: /tmp/nodesource.gpg.key
        state: absent
      when: not nodesource_keyring.stat.exists

    - name: Add NodeSource repository
      become: true
      ansible.builtin.apt_repository:
        repo: "deb [signed-by=/usr/share/keyrings/nodesource.gpg] https://deb.nodesource.com/node_20.x nodistro main"
        filename: nodesource
        state: present
      register: nodesource_repo

    - name: Refresh apt cache if NodeSource repo changed
      become: true
      ansible.builtin.apt:
        update_cache: true
      when: nodesource_repo.changed

    - name: Ensure Node.js is upgraded to latest version (v20+)
      become: true
      ansible.builtin.apt:
        name: nodejs
        state: latest

- name: Update apt cache if Neovim PPA changed
  become: true
  ansible.builtin.apt:
    update_cache: true
  when:
    - neovim_ppa_repo is defined
    - neovim_ppa_repo.changed

- name: Normalize apt package list
  set_fact:
    apt_packages_resolved: "{{ apt_packages_resolved | default([]) | unique }}"

- name: Filter apt packages by repository availability
  when: apt_packages_resolved | length > 0
  block:
    - name: Check apt package availability
      ansible.builtin.shell: |
        set -euo pipefail
        if apt-cache show "{{ item }}" >/dev/null 2>&1; then
          printf '%s' "{{ item }}"
        fi
      args:
        executable: /bin/bash
      loop: "{{ apt_packages_resolved }}"
      register: apt_package_checks
      changed_when: false
      failed_when: false

    - name: Gather available apt packages
      set_fact:
        apt_packages_available: "{{ apt_package_checks.results
          | map(attribute='stdout')
          | reject('equalto', '')
          | list
          | unique }}"

    - name: Warn about missing apt packages
      ansible.builtin.debug:
        msg: >-
          Skipping packages not found in APT repositories: {{ apt_packages_resolved | difference(apt_packages_available | default([])) }}
      when: (apt_packages_resolved | difference(apt_packages_available | default([]))) | length > 0
      changed_when: false

- name: Install apt packages
  become: true
  ansible.builtin.apt:
    name: "{{ apt_packages_available | default([]) }}"
    state: present
    update_cache: true
    cache_valid_time: 3600
  when:
    - apt_packages_available is defined
    - apt_packages_available | length > 0

- name: Compute Linux GUI package names
  set_fact:
    signal_linux_packages: >-
      {{ package_manifest.gui_apps | default([])
         | selectattr('linux', 'defined')
         | selectattr('linux.package', 'defined')
         | map(attribute='linux.package')
         | list }}
  when: ansible_facts['system'] == 'Linux'

- name: Configure Signal Desktop repository
  when:
    - ansible_facts['system'] == 'Linux'
    - signal_linux_packages | select('equalto', 'signal-desktop') | list | length > 0
  block:
    - name: Ensure signal keyring directory exists
      become: true
      ansible.builtin.file:
        path: /usr/share/keyrings
        state: directory
        mode: "0755"

    - name: Check for existing Signal signing key
      ansible.builtin.stat:
        path: /usr/share/keyrings/signal-desktop-keyring.gpg
      register: signal_key

    - name: Download Signal signing key
      ansible.builtin.get_url:
        url: https://updates.signal.org/desktop/apt/keys.asc
        dest: /tmp/signal-desktop-keys.asc
        mode: "0644"
      when: not signal_key.stat.exists

    - name: Install Signal signing key
      become: true
      ansible.builtin.command: gpg --dearmor --output /usr/share/keyrings/signal-desktop-keyring.gpg /tmp/signal-desktop-keys.asc
      args:
        creates: /usr/share/keyrings/signal-desktop-keyring.gpg
      when: not signal_key.stat.exists

    - name: Remove temporary Signal key
      ansible.builtin.file:
        path: /tmp/signal-desktop-keys.asc
        state: absent
      when: not signal_key.stat.exists

    - name: Install Signal Desktop sources list
      become: true
      ansible.builtin.template:
        src: signal-desktop.sources.j2
        dest: /etc/apt/sources.list.d/signal-desktop.sources
        mode: "0644"
      register: signal_repo

    - name: Refresh apt cache after adding Signal repo
      become: true
      ansible.builtin.apt:
        update_cache: true
      when: signal_repo.changed
      changed_when: false

- name: Configure Antigravity repository
  when:
    - ansible_facts['system'] == 'Linux'
    - signal_linux_packages | select('equalto', 'antigravity') | list | length > 0
  block:
    - name: Check for existing Antigravity signing key
      ansible.builtin.stat:
        path: /usr/share/keyrings/antigravity-repo-key.gpg
      register: antigravity_key

    - name: Download Antigravity signing key
      ansible.builtin.get_url:
        url: https://us-central1-apt.pkg.dev/doc/repo-signing-key.gpg
        dest: /tmp/antigravity_key.gpg
        mode: "0644"
      when: not antigravity_key.stat.exists

    - name: Install Antigravity signing key
      become: true
      ansible.builtin.command: gpg --dearmor --yes --output /usr/share/keyrings/antigravity-repo-key.gpg /tmp/antigravity_key.gpg
      when: not antigravity_key.stat.exists

    - name: Remove temporary Antigravity key
      ansible.builtin.file:
        path: /tmp/antigravity_key.gpg
        state: absent
      when: not antigravity_key.stat.exists

    - name: Add Antigravity repository
      become: true
      ansible.builtin.apt_repository:
        repo: "deb [signed-by=/usr/share/keyrings/antigravity-repo-key.gpg] https://us-central1-apt.pkg.dev/projects/antigravity-auto-updater-dev/ antigravity-debian main"
        filename: antigravity
        state: present
      register: antigravity_repo

    - name: Refresh apt cache after adding Antigravity repo
      become: true
      ansible.builtin.apt:
        update_cache: true
      when: antigravity_repo.changed
      changed_when: false

- name: Install Nerd Fonts on Linux
  when:
    - ansible_facts['system'] == 'Linux'
    - package_manifest.fonts | default([]) | length > 0
  vars:
    linux_fonts: >-
      {{ package_manifest.fonts | selectattr('linux', 'defined') | list }}
  block:
    - name: Process Nerd Fonts
      ansible.builtin.include_tasks: install_font.yml
      loop: "{{ linux_fonts }}"
      loop_control:
        loop_var: font_item
        label: "{{ font_item.name }}"

    - name: Rebuild font cache
      ansible.builtin.command: fc-cache -f
      changed_when: true

- name: Install Linux GUI applications
  ansible.builtin.include_tasks: install_gui_app.yml
  loop: "{{ package_manifest.gui_apps | default([]) | selectattr('linux', 'defined') | list }}"
  loop_control:
    loop_var: gui_app
    label: "{{ gui_app.name }}"

- name: Configure Flatpak (if required)
  when: ansible_facts['system'] == 'Linux'
  block:
    - name: Add Flatpak Flathub remote
      become: true
      community.general.flatpak_remote:
        name: flathub
        state: present
        flatpakrepo_url: https://flathub.org/repo/flathub.flatpakrepo
        method: system

    - name: Install Flatpak applications
      ansible.builtin.include_tasks: install_flatpak_app.yml
      loop: "{{ package_manifest.flatpak_apps | default([]) }}"
      loop_control:
        loop_var: flatpak_app
        label: "{{ flatpak_app }}"

- name: Install Linux CLI extras
  when:
    - ansible_facts['system'] == 'Linux'
  block:
    - name: Collect gem-based CLI tools
      set_fact:
        linux_gem_tools: >-
          {{ package_manifest.cli_tools | default([])
             | selectattr('linux', 'defined')
             | selectattr('linux.type', 'defined')
             | selectattr('linux.type', 'equalto', 'gem')
             | list }}

    - name: Install CLI tool via gem
      become: true
      community.general.gem:
        name: "{{ item.linux.package }}"
        state: present
      loop: "{{ linux_gem_tools }}"
      loop_control:
        label: "{{ item.linux.package }}"
      when: linux_gem_tools | length > 0

    - name: Determine gem executable directory
      command: ruby -e 'require "rubygems"; print Gem.bindir'
      register: gem_bindir
      changed_when: false
      when: linux_gem_tools | length > 0

    - name: Stat gem binaries
      ansible.builtin.stat:
        path: "{{ gem_bindir.stdout }}/{{ item.linux.package }}"
      loop: "{{ linux_gem_tools }}"
      loop_control:
        label: "{{ item.linux.package }}"
      register: gem_binary_stats
      when:
        - linux_gem_tools | length > 0
        - gem_bindir.stdout is defined
        - gem_bindir.stdout != ''

    - name: Ensure gem binaries are on PATH
      become: true
      ansible.builtin.file:
        src: "{{ item.stat.path }}"
        dest: "/usr/local/bin/{{ item.item.linux.executable | default(item.item.linux.package) }}"
        state: link
        force: true
      loop: "{{ gem_binary_stats.results | default([]) }}"
      loop_control:
        label: "{{ item.item.linux.package }}"
      when:
        - item.stat.exists | default(false)
        - item.stat.isreg | default(false)

    - name: Ensure PATH includes gem bindir
      ansible.builtin.blockinfile:
        path: "{{ ansible_facts['env']['HOME'] }}/.bashrc"
        marker: "# {mark} gem path"
        block: |
          export PATH={{ gem_bindir.stdout | default('/usr/local/bin') }}:$PATH
      when:
        - gem_bindir.stdout is defined
        - gem_bindir.stdout != ''

    - name: Collect npm-based CLI tools
      set_fact:
        linux_npm_tools: >-
          {{ package_manifest.cli_tools | default([])
             | selectattr('linux', 'defined')
             | selectattr('linux.type', 'defined')
             | selectattr('linux.type', 'equalto', 'npm')
             | list }}

    - name: Install CLI tool via npm
      become: true
      community.general.npm:
        name: "{{ item.linux.package }}"
        global: true
        state: present
      loop: "{{ linux_npm_tools }}"
      loop_control:
        label: "{{ item.linux.package }}"
      when: linux_npm_tools | length > 0

- name: Upgrade Neovim to latest available version
  become: true
  ansible.builtin.apt:
    name: neovim
    state: latest
  when:
    - ansible_facts['system'] == 'Linux'

